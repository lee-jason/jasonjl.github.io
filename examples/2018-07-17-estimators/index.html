<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>Estimation Theory and Machine Learning</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://jasonjl.me/css/style.css">
  <link rel="canonical" href="https://jasonjl.mehttps://jasonjl.me/examples/2018-07-17-estimators/">
  <link rel="alternate" type="application/atom+xml" title="Jason Lee" href="https://jasonjl.mehttps://jasonjl.me/feed.xml" />
  <!-- Basic favicon -->
  <link rel="icon" type="image/x-icon" href="https://jasonjl.me/assets/favicon/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="https://jasonjl.me/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://jasonjl.me/assets/favicon/favicon-16x16.png">

  <!-- Apple Touch Icon -->
  <link rel="apple-touch-icon" sizes="180x180" href="https://jasonjl.me/assets/favicon/apple-touch-icon.png">

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZYPVTW1ZCS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZYPVTW1ZCS');
</script>

</head>

  <body>
    <div class="wrapper">
      <div class="page-content">
        <div class="post">
  <h2>Jason J Lee</h2>
  <header class="post-header">
    <a href=" https://jasonjl.me " class="home-link">← Home</a>
    <h1 class="post-title">Estimation Theory and Machine Learning</h1>
    <p class="post-meta">July 17, 2018</p>
    
  </header>
  <div>


  </div>

  <article class="post-content">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<p>Often it is not possible or simply impractical to compute certain values exactly.
This might be because it is too expensive computationally or because not enough information is available.
Instead, these values can be estimated.
The quality of estimates varies.
In statistics, this concept is formalized in estimation theory <a href="#citation-1" id="ref-1" class="ref-link">[1]</a>
 <a href="#citation-2" id="ref-2" class="ref-link">[2]</a>
.</p>

<p>The first part of this blog post introduces the fundamentals behind estimators.
In the second part, it is shown how they can be applied to machine learning in two different ways.
One of these applications is quantifying the quality of models.
Since models can generally not be perfect for complex problems, it is useful to try to describe how well they work.</p>

<p>Additionally, estimation theory is useful to understand different versions of gradient descent.
Typically, the gradient is only estimated using methods like mini-batch or stochastic gradient descent.
Here, estimation theory can be used to explain the ideas behind these techniques.</p>

<h3 id="estimators-and-their-properties">Estimators and their properties</h3>

<p>An <em>estimator</em> is a function that estimates a value based on other observations.
This process can involve randomness.
For example, because the function itself is random or because there is random noise in the observations it uses.</p>

<h4 id="bias">Bias</h4>

<p>One measure for the quality of an estimator \(\tilde{X}\) is its <em>bias</em> or how far off its estimate is on average from the true value \(X\):</p>

\[\operatorname{bias}({\tilde{X}}) = \mathbb{E}[\tilde{X}] - X\]

<p>where the expected value is over the randomness involved in \(\tilde{X}\).</p>

<p>If the bias of an estimator is \(0\), it is called an <em>unbiased estimator</em>.
This is generally a desirable property to have <a href="#citation-3" id="ref-3" class="ref-link">[3]</a>
 because it means that the estimator is correct on average.
If one samples for long enough from the estimator, the average converges to the true value \(X\).
This is due to the <a href="https://en.wikipedia.org/wiki/Law_of_large_numbers">law of large numbers</a>.</p>

<p><strong>Theorem</strong>: If \(k\) estimators all produce unbiased estimates \(\tilde{X}_1, \dots, \tilde{X}_k\) of \(X\), then any weighted average of them is also an unbiased estimator.
The full estimate is given by</p>

\[\tilde{X} = w_1 * \tilde{X}_1 + \ldots + w_k * \tilde{X}_k\]

<p>where the sum of weights \(\sum_{i = 1}^k w_i = 1\) needs to be normalized.</p>

<p><strong>Proof</strong>: The unbiasedness is due to the <a href="https://en.wikipedia.org/wiki/Expected_value#Linearity">linearity of expectation</a>:</p>

\[\begin{align*}
	\mathbb{E}[\tilde{X}] &amp; = \mathbb{E}[w_1 * \tilde{X}_1 + \ldots + w_k * \tilde{X}_k] \\
	              &amp; = w_1 * \mathbb{E}[\tilde{X}_1] + \ldots + w_k * \mathbb{E}[\tilde{X}_k] \\
	              &amp; = w_1 * X + \ldots + w_k * X \\
	              &amp; = X
\end{align*}\]

<p>This theorem about unbiased estimators is going to prove to be useful later on.</p>

<h4 id="variance">Variance</h4>

<p>However, even if we have an unbiased estimator, its individual estimates can still be far off from the true value.
To quantify how consistently an estimator is close to the true value, another statistic is required.
Commonly, the <em>variance</em> of the estimator is considered here:</p>

\[\operatorname{Var}[\tilde{X}] = \mathbb{E}[(\tilde{X} - X)^2]\]

<p>It is defined as the mean squared distance between the estimate and the value to be estimated.</p>

<h3 id="bias-variance-tradeoff">Bias-variance tradeoff</h3>

<p>Many different things can be analyzed using estimators.
For example, statistical models can be seen as estimators.
They use observations, or data, to make predictions.
These predictions are generally not perfect because randomness is involved and only a limited amount of information is available.
Thus, it makes sense to analyze statistical models in terms of bias and variance.</p>

<p>A central problem when building models is balancing underfitting and overfitting.
If the training data is just memorized, the model does not generalize well to new data.
This is a case of overfitting.
The opposite issue, only barely matching the pattern in the training data, is called underfitting.</p>

<p>This problem is also known as the <a href="https://en.wikipedia.org/wiki/Bias–variance_tradeoff"><em>bias-variance tradeoff</em></a> <a href="#citation-4" id="ref-4" class="ref-link">[4]</a>
 <a href="#citation-5" id="ref-5" class="ref-link">[5]</a>
.
If the model has a high bias, its predictions are off, which corresponds to underfitting.
If overfitting occurred, i.e. the data is matched too well, the estimates have a high variance.
By resampling the data that the model was built on, totally different estimates are generated.
This is because the model is now based on different random noise.</p>

<p>Generally, it is not possible to perfectly optimize both, bias and variance, so they need to be balanced here.
In other words, we accept a certain bias of the model to keep its variance low.
A good tradeoff between the two needs to be achieved.</p>

<h3 id="gradient-descent">Gradient descent</h3>

<p>In supervised machine learning, we compare our model’s predictions to the true labels.
This is done using a loss function.
If a set of data points \(x_1, \dots, x_n\) and labels \(y_1, \dots\, y_n\) is given, then the full loss is defined by</p>

\[L = \frac{1}{n} \sum\limits_{i = 1}^n \operatorname{loss}(f(x_i), y_i)\]

<p>where \(\operatorname{loss}\) is a function that compares a prediction \(p\) to the correct answer \(y\).
One choice for the loss function might be the quadratic error:</p>

\[\operatorname{loss}(p, y) = (p - y)^2\]

<p><a href="https://en.wikipedia.org/wiki/Gradient_descent">Gradient descent</a> optimizes the parameters used in \(f\) by computing the gradient of the loss with respect to these parameters.
This gradient is then used to continually improve the parameters step by step.</p>

<h4 id="full-batch-gradient-descent">Full-batch gradient descent</h4>

<p>To compute the gradient \(\nabla L\) of the loss, we can make use of the <a href="https://en.wikipedia.org/wiki/Gradient#Linearity">linearity of the gradient operator</a>:</p>

\[\begin{align*}
	\nabla L &amp; = \nabla \frac1n \sum\limits_{i = 1}^n \operatorname{loss}(f(x_i), y_i) \\
	         &amp; = \frac1n \sum\limits_{i = 1}^n \nabla \operatorname{loss}(f(x_i), y_i)
\end{align*}\]

<p>The method that uses the gradient given above is sometimes referred to as <em>full-batch gradient descent</em> because it fully uses the available training data in each iteration.
In many cases, \(n\) is a very large value and computing the full update \(\nabla L\) is expensive.
Since computing the gradient is by far the most expensive part of gradient descent, it makes sense to try to make this more efficient.</p>

<p>Computing the gradient as shown above is especially inefficient if there is duplicated training data.
If the training set consists of 10 copies of a different dataset, then the evaluation of the formula above is unnecessarily expensive.
Every required calculation is repeated 10 times.
While this is an extreme example, it does happen in practice that much of the training data is similar.
To save time, it often makes sense to only use a part of the data to estimate the gradient.</p>

<h4 id="stochastic-gradient-descent">Stochastic gradient descent</h4>

<p>In <em>stochastic gradient descent</em> (<em>SGD</em>), a single data point \(x\) and label \(y\) are sampled uniformly from the training set.
The true gradient \(\nabla L\) is then estimated using only this data point and label:</p>

\[\nabla \tilde{L} = \nabla \operatorname{loss}(f(x), y)\]

<p>It is easy to see that \(\nabla \tilde{L}\) is an unbiased estimator of \(\nabla L\):</p>

\[\begin{align*}
	\mathbb{E}[\nabla \tilde{L}] &amp; = \sum\limits_{i = 1}^n \frac{1}{n} \nabla \operatorname{loss}(f(x_i), y_i)  \\
	                     &amp; = \frac1n \nabla \sum\limits_{i = 1}^n \operatorname{loss}(f(x_i), y_i) \\
	                     &amp; = \nabla L
\end{align*}\]

<p>The computations for SGD can be performed very quickly but still give us an unbiased estimate of the true gradient.
This property is the reason why optima can be found using this algorithm.
While individual estimates are off, the randomness averages out over iterations and the parameters still move in a sensible direction overall.
Since iterations are much cheaper, many more of them can be performed and this is a major improvement to computing the full gradient.</p>

<h4 id="mini-batch-gradient-descent">Mini-batch gradient descent</h4>

<p>These individual SGD estimates can have a large variance however, leading to noisy and jumpy updates.
A further improvement over this method is <em>mini-batch gradient descent</em>.
Instead of just sampling one data point, we sample a small batch of \(k\) examples.
The estimated gradient is an average of all \(k\) single estimates.</p>

<p>Each of these individual estimators is unbiased since SGD itself is unbiased.
As shown in the theorem earlier, a weighted combination of them still remains an unbiased estimator.
Thus, mini-batch gradient descent is also an unbiased way of computing gradient estimates.</p>

<p>Mini-batch gradient descent does have much less variance, however, because more data is used to compute the estimate.
This makes the optimization process more stable compared to using SGD.</p>

<p>Most gradient computations can be formulated using linear algebra operations.
These calculations can be parallelized very well on GPUs <a href="#citation-6" id="ref-6" class="ref-link">[6]</a>
.
So with appropriate hardware there is no significant performance penalty for using \(1 &lt; k \ll n\) data points to compute the estimate.
Thus mini-batch gradient descent is typically not much slower than SGD but leads to a more stable optimization process.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Estimators provide an elegant way of analyzing the quality of estimates.
In machine learning, estimates play an important role because data contains a lot of random noise and because it is often more practical to only estimate values.
The quality of statistical models can be described in terms of bias and variance.
Too much bias corresponds to underfitting, while too much variance is equivalent to overfitting.
The training process needs to find a tradeoff between these two.</p>

<p>To compute the gradient for the optimization process, it is expensive to use all data points.
By randomly sampling them, we can compute unbiased estimates in a much faster way.
If this is done using a large enough sample, the variance of these estimates does not have to be large.
By properly choosing the sample size, the optimization process can thus be speeded up significantly.</p>

<h3 id="references">References</h3>

<ol class="references-list">
	
	<li><span id="citation-1">Diez, D.M., Barr, C.D. and Cetinkaya-Rundel, M., 2012. OpenIntro statistics (Vol. 12). CreateSpace.
		
		
		
		<a href="#ref-1" class="ref-backlink"></a>
		
	</span>
</li>

	<li><span id="citation-2">Härdle, W. and Simar, L., 2007. Applied multivariate statistical analysis (Vol. 22007, pp. 1051-8215). Berlin: Springer. Vancouver
		
		
		
		<a href="#ref-2" class="ref-backlink"></a>
		
	</span>
</li>

	<li><span id="citation-3">Voinov, V.G. and Nikulin, M.S., 2012. Unbiased Estimators and Their Applications: Volume 1: Univariate Case (Vol. 263). Springer Science &amp; Business Media.
		
		
		
		<a href="#ref-3" class="ref-backlink"></a>
		
	</span>
</li>

	<li><span id="citation-4">Raul Rojas. The bias-variance dilemma. Freie University, Berlin, Tech. Rep, 2015.
		
		
		
		<a href="#ref-4" class="ref-backlink"></a>
		
	</span>
</li>

	<li><span id="citation-5">Friedman, J., Hastie, T. and Tibshirani, R., 2001. The elements of statistical learning (Vol. 1, No. 10). New York, NY, USA:: Springer series in statistics.
		
		
		
		<a href="#ref-5" class="ref-backlink"></a>
		
	</span>
</li>

	<li><span id="citation-6">Navarro, C.A., Hitschfeld-Kahler, N. and Mateu, L., 2014. A survey on parallel computing and its applications in data-parallel problems using GPU architectures. Communications in Computational Physics, 15(2), pp.285-329.
		
		
		
		<a href="#ref-6" class="ref-backlink"></a>
		
	</span>
</li>


</ol>

<script src="https://unpkg.com/tippy.js@3/dist/tippy.all.min.js"></script>

<script>
var alreadySeenRefs = {};

document.querySelectorAll(".ref-link").forEach(function (a) {
  var id = a.getAttribute("id");
  var citationPath = "#" + id.replace("ref", "citation");

  tippy(a, {
  	  content: document.querySelector(citationPath).textContent, placement: "bottom",
  	  arrow: true
  })

  if (id in alreadySeenRefs) return;

  var p = a.closest("p");
  var currentId = p.getAttribute("id");

  if (currentId == null) {
    p.setAttribute("id", id)
  } else {
    document.querySelector(citationPath + " a.ref-backlink").setAttribute("href", "#" + currentId)
  }

  alreadySeenRefs[id] = true;
  a.removeAttribute("id")
})
</script>


  </article>

  
  <div class="comments">
    <div id="disqus_thread"></div>
<script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://jihoon222.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  </div>
</div>

<script>
var anchorForId = function (id) {
  var anchor = document.createElement("a");
  anchor.className = "header-link";
  anchor.href      = "#" + id;
  anchor.innerHTML = "<i class=\"fas fa-link\"></i>";
  return anchor;
};

var linkifyAnchors = function (level, containingElement) {
  var headers = containingElement.getElementsByTagName("h" + level);
  for (var h = 0; h < headers.length; h++) {
    var header = headers[h];

    if (typeof header.id !== "undefined" && header.id !== "") {
      header.appendChild(anchorForId(header.id));
    }
  }
};

document.onreadystatechange = function () {
  if (this.readyState === "complete") {
    linkifyAnchors(3, document.body);
    linkifyAnchors(4, document.body);
    linkifyAnchors(5, document.body);
    linkifyAnchors(6, document.body);
  }
};
</script>

      </div>
    </div>
  </body>
</html>
