<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>Diffing</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://jasonjl.me/css/style.css">
  <link rel="canonical" href="https://jasonjl.mehttps://jasonjl.me/examples/2020-12-29-diffing/">
  <link rel="alternate" type="application/atom+xml" title="Jason Lee" href="https://jasonjl.mehttps://jasonjl.me/feed.xml" />
  <!-- Basic favicon -->
  <link rel="icon" type="image/x-icon" href="https://jasonjl.me/assets/favicon/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="https://jasonjl.me/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://jasonjl.me/assets/favicon/favicon-16x16.png">

  <!-- Apple Touch Icon -->
  <link rel="apple-touch-icon" sizes="180x180" href="https://jasonjl.me/assets/favicon/apple-touch-icon.png">

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZYPVTW1ZCS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZYPVTW1ZCS');
</script>

</head>

  <body>
    <div class="wrapper">
      <div class="page-content">
        <div class="post">
  <h2>Jason J Lee</h2>
  <header class="post-header">
    <a href=" https://jasonjl.me " class="home-link">← Home</a>
    <h1 class="post-title">Diffing</h1>
    <p class="post-meta">December 29, 2020</p>
    
  </header>
  <div>


  </div>

  <article class="post-content">
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<link rel="stylesheet" href="/assets/posts/diffing/diffing-visualization.css" />

<style>
.added, .removed, .unchanged {
  font-weight: bold;
  background-color: rgb(245, 245, 245);
  padding: 2px;
  border-radius: 9px;
}

.added {
  color: rgb(0, 221, 0);
}

.removed {
  color: rgb(218, 16, 16);
}

.unchanged {
  white-space: pre;
  padding: 0 5px;
}
</style>

<p>If you’re into coding, chances are that you’ve seen diff views before.
They usually have two sides: The left shows you the old state of a file, the right
shows you the new state, and there are <span class="removed">-</span>
and <span class="added">+</span> markers indicating what changed.</p>

<div id="demo-initial"></div>

<p>But how does this actually work? And can we implement our own differ? It turns
out that it’s actually based on just a few really elegant ideas.</p>

<h3 id="optimal-diffing">Optimal Diffing</h3>

<p>You probably already guessed that we’ll implement our own diffing tool in this post.
In fact, we’ll implement the diffing algorithm which results in the smallest
possible number of <span class="removed">-</span> and
<span class="added">+</span> markers.</p>

<p>We will do this by finding the <em>longest common subsequence</em>, a pretty standard
dynamic programming problem. The rest of the post first explains this problem
and then shows how it can be used to perform diffing.</p>

<h3 id="longest-common-subsequence-lcs">Longest Common Subsequence (LCS)</h3>

<p>Given two sequences S1 and S2, a <em>common subsequence</em> is a sequence that is a
subsequence of both S1 and S2. Note that subsequences do not have to be
contiguous. For example, consider these two sequences:</p>

<ul>
  <li>S1: <code class="language-plaintext highlighter-rouge">ABCDE</code></li>
  <li>S2: <code class="language-plaintext highlighter-rouge">ABZZE</code></li>
</ul>

<p>Here, <code class="language-plaintext highlighter-rouge">AE</code> would be a common subsequence. The <em>longest common subsequence</em> (the
<em>LCS</em>) is the longest such subsequence. In our example this is <code class="language-plaintext highlighter-rouge">ABE</code>.</p>

<p>Here’s the fundamental insight behind why the LCS is useful for diffing:
The LCS corresponds exactly to the unchanged parts of a diff, i.e. the parts
that exist in both S1 and S2. Because we find the <em>longest</em> common subsequence,
this means that we maximize the amount of unchanged parts in the diff. In the
same way, we minimize the number of change markers.</p>

<p>This is the fundamental idea behind solving diffing this way. Just that
realization already seems pretty cool to me: At first, finding the LCS seems
like such an abstract problem, but it actually has really nice applications,
such as diffing.</p>

<h4 id="recursive">Recursive</h4>

<p>Instead of finding the LCS itself, let’s start by just computing its <em>length</em>.</p>

<p>We will do so in a recursive way. Let \(f(i, j)\) be the length of the LCS
when considering the first \(i\) characters of S1 and the first \(j\)
characters of S2. Note that \(i = 0\) corresponds to the empty string for S1,
while \(i = |S1|\) would correspond to the full string.</p>

<p>We will recursively find the length of the LCS for different substrings
(i.e. \(i, j\) combinations) to build up the final result of \(f(|S1|, |S2|)\).
This works as follows:</p>

\[f(i, j) =  \begin{cases}
    0 &amp; \text{if } i = 0 \text{ or } j = 0 \\
    1 + f(i - 1, j - 1) &amp; \text{if } S1[i - 1] = S2[j - 1] \\
    \max\{f(i - 1, j), f(i, j - 1)\} &amp; \text{otherwise}
    \end{cases}\]

<p>Let’s go through these cases individually.</p>

<h5 id="1-recursion-base-case-empty-strings-ie-i--0-or-j--0">1. Recursion base case: Empty strings, i.e. \(i = 0\) or \(j = 0\)</h5>

<p>If one of the two strings is empty, then the only common subsequence is the
empty string. The empty string has length 0, so we can directly return that
and end the recursion.</p>

<h5 id="2-the-currently-considered-elements-match-s1i---1--s2j---1">2. The currently considered elements match: \(S1[i - 1] = S2[j - 1]\)</h5>

<p>If the \(i\)-th and the \(j\)-th elements match, then we can increase the
length of the currently considered subsequence by \(1\), and continue with
the remaining strings.</p>

<p>Note that we index using \(i - 1\), \(j - 1\) because indexing starts at 0
while we agreed that \(i = 1\) would correspond to the first element and \(i
= 0\) to the empty string.</p>

<h5 id="3-in-any-other-case-drop-one-character">3. In any other case, drop one character</h5>

<p>In any other case, we have two options:</p>

<ol>
  <li>We ignore the \(i\)-th character of S1: \(f(i - 1, j)\)</li>
  <li>We ignore the \(j\)-th character of S2: \(f(i, j - 1)\)</li>
</ol>

<p>We consider both options and then take the better one, i.e. the one yielding
the larger (\(\max\)) sequence.</p>

<h5 id="combining-the-cases">Combining the cases</h5>

<p>All of these cases together allow us to compute the length of the LCS. Note
that this recursion is really similar to computing the <a href="https://en.wikipedia.org/wiki/Edit_distance">edit
distance</a> of two strings. The only
differences are that we now keep track of the matching parts (not the ones that
have to be changed) and that we only have <em>add</em> and <em>remove</em> operations (no
<em>change</em> operation).</p>

<h4 id="dynamic-programming">Dynamic Programming</h4>

<p>Directly implementing the above recursion would be inefficient because there’s
a lot of repeated subcalls. Each time one of these subcalls is made, we compute
the result from scratch and perform new recursive calls, leading to an
exponential complexity. Instead of doing that, we could cache the results to
reduce the complexity down to quadratic.</p>

<p>It turns out, we can also build the results in a bottom-up manner using dynamic
programming. This is because each recursive call only uses subresults from
\(i - 1\) and \(j - 1\).</p>

<p>This works as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">compute_lcs_len</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">):</span>
  <span class="sh">"""</span><span class="s">Computes a table of f(i, j) results.</span><span class="sh">"""</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">text1</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">text2</span><span class="p">)</span>

  <span class="c1"># We store the results in a (n + 1) x (m + 1) matrix. The +1s are to
</span>  <span class="c1"># allocate space for the empty strings. Cell [i][j] will cache the
</span>  <span class="c1"># result of f(i, j).
</span>  <span class="n">lcs</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
               <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

  <span class="c1"># We then fill the matrix by going through all rows, using the fact
</span>  <span class="c1"># that each call only needs results from the previous (i - 1) or
</span>  <span class="c1"># same (i) row, and from the previous (j - 1) or same (j) column.
</span>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
      <span class="c1"># The remaining code is exactly the same recursion as before, but
</span>      <span class="c1"># we do not make recursive calls and instead use the results cached
</span>      <span class="c1"># in the matrix.
</span>      <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">lcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">elif</span> <span class="n">text1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">text2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="n">lcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">lcs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">lcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">lcs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">lcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

  <span class="k">return</span> <span class="n">lcs</span>
</code></pre></div></div>

<p>The returned matrix tells us the results of all \(f(i, j)\). The length of
the LCS is then stored in the cell of the last row and column.</p>

<h3 id="reconstructing-the-lcs">Reconstructing the LCS</h3>

<p>It might seem weird that so far we focused on finding the length of the LCS
rather than the LCS itself. However, the matrix we built up actually tells us
exactly how we can find the LCS. Not only that, but it also tells us where
<span class="added">+</span> added and <span class="removed">-</span> removed
parts are.</p>

<p>As a next step, we will focus on reconstructing the actual LCS. Afterwards, we
will then adapt the code to find <span class="added">+</span> additions and
<span class="removed">-</span> removals.</p>

<p>To find the actual LCS string, we traverse the matrix we built up in the
previous step, in a way that we always follow the path of the LCS. That is,
we traverse equivalent to the previous recursion and take the \(\max\)
option when there’s a choice.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_lcs_string</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">):</span>
  <span class="sh">"""</span><span class="s">Finds the longest common subsequence of the given texts.</span><span class="sh">"""</span>
  <span class="n">result</span> <span class="o">=</span> <span class="sh">""</span>
  <span class="n">lcs</span> <span class="o">=</span> <span class="nf">compute_lcs_len</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">)</span>

  <span class="n">i</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">text1</span><span class="p">)</span>
  <span class="n">j</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">text2</span><span class="p">)</span>

  <span class="c1"># We iterate until we reach the end of text1 (i == 0) or text2 (j == 0)
</span>  <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># If the parts of text1 and text2 that we consider are equal, then we
</span>    <span class="c1"># can record this as part of the LCS, and move to i-1, j-1 since this
</span>    <span class="c1"># is also how compute_lcs_len traversed.
</span>    <span class="k">if</span> <span class="n">text1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">text2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
      <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">text1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
      <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="c1"># Otherwise, compute_lcs_len went into the max direction, which is
</span>    <span class="c1"># also what we do here.
</span>    <span class="k">elif</span> <span class="n">lcs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
      <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>

  <span class="c1"># Reverse results because we iterated over the texts from the end but
</span>  <span class="c1"># want the results to be in forward order.
</span>  <span class="k">return</span> <span class="nf">reversed</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<p>Note how we traversed exactly the way the optimal recursion would traverse. If
we were to print the results, we would now get the LCS, i.e. the unchanged
parts of the diff.</p>

<h3 id="from-lcs-to-diffing">From LCS to Diffing</h3>

<p>Now we only need to find the <span class="added">+</span> additions and <span class="removed">-</span> removals. Luckily we already have all required
information in the LCS table we built up.</p>

<h4 id="code">Code</h4>

<p>We pretty much follow the same logic as the LCS traversal but break some cases
up further to account for <span class="added">+</span> additions and <span class="removed">-</span> removals.</p>

<p>Let’s first take a look at the code, and then discuss the cases a bit more.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">):</span>
  <span class="sh">"""</span><span class="s">Computes the optimal diff of the two given inputs.

  The result is a list where all elements are Removals, Additions or
  Unchanged elements.
  </span><span class="sh">"""</span>
  <span class="n">lcs</span> <span class="o">=</span> <span class="nf">compute_lcs_len</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">)</span>
  <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="n">i</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">text1</span><span class="p">)</span>
  <span class="n">j</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">text2</span><span class="p">)</span>

  <span class="c1"># We iterate until we reach the end of both texts.
</span>  <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># If we reached the end of one of text1 (i == 0) or text2 (j == 0),
</span>    <span class="c1"># then we just need to print the remaining additions and removals.
</span>    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">results</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nc">Addition</span><span class="p">(</span><span class="n">text2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
      <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">results</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nc">Removal</span><span class="p">(</span><span class="n">text1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
      <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="c1"># Otherwise there's still parts of text1 and text2 left. If the
</span>    <span class="c1"># currently considered parts are equal, then we found an unchanged
</span>    <span class="c1"># part which belongs to the longest common subsequence.
</span>    <span class="k">elif</span> <span class="n">text1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">text2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
      <span class="n">results</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nc">Unchanged</span><span class="p">(</span><span class="n">text1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
      <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="c1"># In any other case, we go in the direction of the longest common
</span>    <span class="c1"># subsequence.
</span>    <span class="k">elif</span> <span class="n">lcs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
      <span class="n">results</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nc">Addition</span><span class="p">(</span><span class="n">text2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
      <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">results</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nc">Removal</span><span class="p">(</span><span class="n">text1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
      <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>

  <span class="c1"># Reverse results because we iterated over the texts from the end but
</span>  <span class="c1"># want the results to be in forward order.
</span>  <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="nf">reversed</span><span class="p">(</span><span class="n">results</span><span class="p">))</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">Unchanged</code>, <code class="language-plaintext highlighter-rouge">Addition</code>, <code class="language-plaintext highlighter-rouge">Removal</code> are just simple <a href="https://docs.python.org/3/library/dataclasses.html">data
classes</a> that hold the
content.</p>

<h4 id="going-through-the-cases">Going through the cases</h4>

<p>Let’s discuss these cases in some more detail.</p>

<h5 id="1-base-case-both-strings-are-empty-ie-i--0-and-j--0">1. Base case: Both strings are empty, i.e. \(i = 0\) and \(j = 0\)</h5>

<p>No more diffs can be produced, so we terminate.</p>

<h5 id="2-only-one-string-is-empty-ie-i--0-or-j--0">2. Only one string is empty, i.e. \(i = 0\) or \(j = 0\)</h5>

<p>If exactly one of the two strings is empty, then the other must contain
additions or removals:</p>

<ol>
  <li>S1 is empty, but S2 is not: This means something was <em>added</em> in S2 and we
have to record these elements as <span class="added">+</span> additions</li>
  <li>S2 is empty, but S1 is not: This means something was <em>removed</em> from S1 and
we have to record these elements as <span class="removed">-</span> removals</li>
</ol>

<h5 id="3-the-currently-considered-elements-match-s1i---1--s2j---1">3. The currently considered elements match: \(S1[i - 1] = S2[j - 1]\)</h5>

<p>As discussed previously, these elements are part of the LCS and as such
must be <br /> <span class="unchanged"> </span> <em>unchanged</em> elements.</p>

<h5 id="4-in-any-other-case-drop-one-character">4. In any other case, drop one character</h5>

<p>In the last case, the LCS recursion dropped either a character from S1 (meaning
\(i - 1\)) or from S2 (meaning \(j - 1\)). The LCS table tells us which one
lead to the optimal (\(\max\)) result:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">lcs[i - 1][j] &lt; lcs[i][j - 1]</code>: Here, <code class="language-plaintext highlighter-rouge">j - 1</code> leads to a longer LCS, meaning
that we have to record an <span class="added">+</span> addition to <code class="language-plaintext highlighter-rouge">S2</code>,
since this is where an element was skipped for the LCS</li>
  <li><code class="language-plaintext highlighter-rouge">lcs[i - 1][j] &gt; lcs[i][j - 1]</code>: Here, <code class="language-plaintext highlighter-rouge">i - 1</code> leads to a longer LCS, meaning
that we have to record a <span class="removed">-</span> removal from <code class="language-plaintext highlighter-rouge">S1</code>,
since this is where an element was skipped for the LCS</li>
  <li><code class="language-plaintext highlighter-rouge">lcs[i - 1][j] == lcs[i][j - 1]</code>: If both alternatives are equal, then it
means that both an <span class="added">+</span> addition and a <span class="removed">-</span> removal happened. Which one we process first does
not matter too much since it only influences which one is displayed first</li>
</ol>

<p>Afterwards, we update <code class="language-plaintext highlighter-rouge">i, j</code> exactly as the recursive LCS algorithm did.</p>

<h3 id="variants">Variants</h3>

<h4 id="split-view-diffing">Split-view diffing</h4>

<p>We are actually pretty much done now. The code above gives us a results list
which tells us which elements remained <span class="unchanged"> </span>
unchanged, were <span class="removed">-</span> removed or <span class="added">+</span> added. We could now directly render this to produce a
unified diff view:</p>

<div id="demo-unified"></div>

<p>As you can see, this shows all diff results in a single view.</p>

<p>However, as mentioned at the very beginning of the post, most diffing tools
also allow you to display results in a split view. The left shows <span class="removed">-</span> removals, the right side <span class="added">+</span>
additions:</p>

<div id="demo-split"></div>

<p>It turns out this is not too difficult to implement once you have the above
algorithm in place. We still use the results list we previously produced
and just render it twice:</p>

<ol>
  <li>The left side only renders <span class="removed">-</span> removals and <span class="unchanged"> </span> unchanged parts</li>
  <li>The right side only renders <span class="added">+</span> additions and <span class="unchanged"> </span> unchanged parts.</li>
</ol>

<p>Additionally some book-keeping has to be done to figure out how many buffer
lines ones needs to insert in order for the left and right side to line up
nicely.</p>

<h4 id="char-level-vs-word-level-vs-line-level-diffing">Char-level vs word-level vs line-level diffing</h4>

<p>Something that might have been confusing so far is that all live demos showed
diffs on a <em>line</em>-level, while our code never explicitly handled lines in any
way. In fact, the algorithm and code have no notion of lines on purpose.
Instead, they work on generic sequences.</p>

<p>This means you could implement different types of diff levels, just by
controlling what is passed to the <code class="language-plaintext highlighter-rouge">diff</code> function:</p>

<ul>
  <li>Character-level: Just pass in the strings directly (or in some programming
languages: pass in arrays of characters)</li>
  <li>Word-level: Tokenize each text and then pass in arrays of tokens</li>
  <li>Line-level: Split the texts by lines and pass in arrays of lines</li>
</ul>

<p>For all of these, the <code class="language-plaintext highlighter-rouge">diff</code> function stays the same. The only thing that
changes is how you call it and how results have to be rendered in the
visualization.</p>

<p>However, you can optimize word-level and line-level diffing with hashing
to potentially speed up the <code class="language-plaintext highlighter-rouge">==</code> comparisons: First, store hashes of all
elements. Then, when you want to compare elements, compare their hashes,
and only compare the contents if the hashes do not match.</p>

<h3 id="is-it-really-optimal">Is It Really Optimal?</h3>

<p>The algorithm we discussed is optimal in the sense that it produces the
minimum number of change markers. However, sometimes I find this to produce
pretty annoying results.</p>

<p>For example, consider this diff:</p>

<div id="demo-suboptimal"></div>

<p>We really only added one entire function, but because there is overlap with the
previous function, this is not displayed as one added function but as
a change that split up the original function in the file.</p>

<p>It is worth noting that I think all code review tools I used so far had this
problem. I can also think of some heuristics to fix this particular case, but
that seems out of scope for this blog post, and I’m not sure if any of them
would generalize nicely.</p>

<h3 id="conclusion">Conclusion</h3>

<p>As we saw, finding the longest common subsequence (LCS) is equivalent to
finding the <span class="unchanged"> </span> unchanged parts of a diff. The
same dynamic programming solution also allows us to reconstruct the <span class="removed">-</span> removed and <span class="added">+</span> added parts.</p>

<p>There’s several things I find neat about this: For one, finding the LCS seems
like such a theoretical problem in the beginning, but then it has really cool
applications. Furthermore, you can build your own diffing tool using a few
really elegant ideas instead of hacking away tons of complex rules and
heuristics. This was definitely something I did not previously realize.</p>

<h3 id="appendix-code">Appendix: Code</h3>

<p>If you are curious about the full code, I put my entire Python implementation
on GitHub at <a href="https://github.com/florian/diff-tool">florian/diff-tools</a>. I also
wrote a <a href="https://github.com/florian/diff-tool/tree/main/react">JavaScript implementation</a>
to power the live demos in this blog post. That code and the matching React
visualization code are also on GitHub.</p>

<h3 id="references">References</h3>

<ol class="references-list">
	
	<li><span id="citation-1">Hunt, James Wayne, and M. Douglas MacIlroy. An algorithm for differential file comparison. Murray Hill: Bell Laboratories, 1976. APA
		 <a href="https://www.cs.dartmouth.edu/~doug/diff.pdf" class="pdf-link"></a> 
		
		
	</span>
</li>

	<li><span id="citation-2">Hirschberg, Daniel S. "A linear space algorithm for computing maximal common subsequences." Communications of the ACM 18.6 (1975): 341-343. APA
		 <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.348.4774&amp;rep=rep1&amp;type=pdf" class="pdf-link"></a> 
		
		
	</span>
</li>


</ol>

<script src="https://unpkg.com/tippy.js@3/dist/tippy.all.min.js"></script>

<script>
var alreadySeenRefs = {};

document.querySelectorAll(".ref-link").forEach(function (a) {
  var id = a.getAttribute("id");
  var citationPath = "#" + id.replace("ref", "citation");

  tippy(a, {
  	  content: document.querySelector(citationPath).textContent, placement: "bottom",
  	  arrow: true
  })

  if (id in alreadySeenRefs) return;

  var p = a.closest("p");
  var currentId = p.getAttribute("id");

  if (currentId == null) {
    p.setAttribute("id", id)
  } else {
    document.querySelector(citationPath + " a.ref-backlink").setAttribute("href", "#" + currentId)
  }

  alreadySeenRefs[id] = true;
  a.removeAttribute("id")
})
</script>

<script src="https://fb.me/react-15.1.0.js"></script>

<script src="https://fb.me/react-dom-15.1.0.js"></script>

<script src="/assets/posts/diffing/diffing-visualization.js"></script>


  </article>

  
  <div class="comments">
    <div id="disqus_thread"></div>
<script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://jihoon222.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  </div>
</div>

<script>
var anchorForId = function (id) {
  var anchor = document.createElement("a");
  anchor.className = "header-link";
  anchor.href      = "#" + id;
  anchor.innerHTML = "<i class=\"fas fa-link\"></i>";
  return anchor;
};

var linkifyAnchors = function (level, containingElement) {
  var headers = containingElement.getElementsByTagName("h" + level);
  for (var h = 0; h < headers.length; h++) {
    var header = headers[h];

    if (typeof header.id !== "undefined" && header.id !== "") {
      header.appendChild(anchorForId(header.id));
    }
  }
};

document.onreadystatechange = function () {
  if (this.readyState === "complete") {
    linkifyAnchors(3, document.body);
    linkifyAnchors(4, document.body);
    linkifyAnchors(5, document.body);
    linkifyAnchors(6, document.body);
  }
};
</script>

      </div>
    </div>
  </body>
</html>
