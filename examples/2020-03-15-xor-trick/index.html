<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>That XOR Trick</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://jasonjl.me/css/style.css">
  <link rel="canonical" href="https://jasonjl.mehttps://jasonjl.me/examples/2020-03-15-xor-trick/">
  <link rel="alternate" type="application/atom+xml" title="Jason Lee" href="https://jasonjl.mehttps://jasonjl.me/feed.xml" />
  <!-- Basic favicon -->
  <link rel="icon" type="image/x-icon" href="https://jasonjl.me/assets/favicon/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="https://jasonjl.me/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://jasonjl.me/assets/favicon/favicon-16x16.png">

  <!-- Apple Touch Icon -->
  <link rel="apple-touch-icon" sizes="180x180" href="https://jasonjl.me/assets/favicon/apple-touch-icon.png">

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZYPVTW1ZCS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZYPVTW1ZCS');
</script>

</head>

  <body>
    <div class="wrapper">
      <div class="page-content">
        <div class="post">
  <h2>Jason J Lee</h2>
  <header class="post-header">
    <a href=" https://jasonjl.me " class="home-link">← Home</a>
    <h1 class="post-title">That XOR Trick</h1>
    <p class="post-meta">March 15, 2020</p>
    
  </header>
  <div>


  </div>

  <article class="post-content">
    <p>There are a whole bunch of popular interview questions that can be solved in one of two ways:
Either using common data structures and algorithms in a sensible manner, or by using some properties of XOR in a seemingly hard to understand way.</p>

<p>While it seems unreasonable to expect the XOR solutions in interviews, it is quite fun to figure out how they work.
As it turns out, they are all based on the same fundamental trick, which we will derive in a bottom-up way in this post.
Afterwards we will look at a bunch of applications of <em>that XOR trick</em> ™, such as solving this popular interview question:</p>

<blockquote>
  <p>You are given an array of n - 1 integers which are in the range between 1 and n. All numbers appear exactly once, except one number, which is missing. Find this missing number.</p>
</blockquote>

<p>Of course, there are a number of straightforward ways to solve this problem, but there is also a perhaps surprising one using XOR.</p>

<h3 id="xor">XOR</h3>

<p>XOR is a logical operator that works on bits.
Let’s denote it by <code class="language-plaintext highlighter-rouge">^</code>.
If the two bits it takes as input are the same, the result is <code class="language-plaintext highlighter-rouge">0</code>, otherwise it is <code class="language-plaintext highlighter-rouge">1</code>.
This implements an <em>exclusive or</em> operation, i.e. exactly one argument has to be <code class="language-plaintext highlighter-rouge">1</code> for the final result to be <code class="language-plaintext highlighter-rouge">1</code>.
We can show this using a truth table:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x</code></th>
      <th><code class="language-plaintext highlighter-rouge">y</code></th>
      <th><code class="language-plaintext highlighter-rouge">x ^ y</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>Most programming languages implement <code class="language-plaintext highlighter-rouge">^</code> as a bitwise operator, meaning XOR is individually applied to each bit in a string of bits (e.g. a byte).</p>

<p>For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0011 ^ 0101 = 0110
</code></pre></div></div>

<p>since</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
</code></pre></div></div>

<p>Because of this, we can apply XOR to anything, not just booleans.</p>

<h3 id="deducing-some-useful-properties">Deducing Some Useful Properties</h3>

<p>We can derive a bunch of properties from the previous definition.
Let’s go through them one by one, and then compose them to solve the interview questions previously mentioned.</p>

<h4 id="xor-and-0-x--0--x">XOR and 0: <code class="language-plaintext highlighter-rouge">x ^ 0 = x</code></h4>

<p>If one of the two arguments to XOR is <code class="language-plaintext highlighter-rouge">0</code>, then the remaining argument is the result.
This directly follows from the truth table by checking the rows where <code class="language-plaintext highlighter-rouge">y = 0</code>, namely the first and third row.</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x</code></th>
      <th><code class="language-plaintext highlighter-rouge">y</code></th>
      <th><code class="language-plaintext highlighter-rouge">x ^ y</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>0</strong></td>
      <td><strong>0</strong></td>
      <td><strong>0</strong></td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td><strong>1</strong></td>
      <td><strong>0</strong></td>
      <td><strong>1</strong></td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<h4 id="xor-on-the-same-argument-x--x--0">XOR on the same argument: <code class="language-plaintext highlighter-rouge">x ^ x = 0</code></h4>

<p>If the two arguments are the same, the result is always <code class="language-plaintext highlighter-rouge">0</code>.
Again, we can convince ourselves that this is true by inspecting the truth table.
This time we have to check the rows where <code class="language-plaintext highlighter-rouge">x = y</code>, i.e. the first and last row.</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x</code></th>
      <th><code class="language-plaintext highlighter-rouge">y</code></th>
      <th><code class="language-plaintext highlighter-rouge">x ^ y</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>0</strong></td>
      <td><strong>0</strong></td>
      <td><strong>0</strong></td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td><strong>1</strong></td>
      <td><strong>1</strong></td>
      <td><strong>0</strong></td>
    </tr>
  </tbody>
</table>

<p>Intuitively, this means that if we apply XOR to the same arguments, they cancel each other out.</p>

<h4 id="commutativity-x--y--y--x">Commutativity: <code class="language-plaintext highlighter-rouge">x ^ y = y ^ x</code></h4>

<p>XOR is commutative, meaning we can change the order in which we apply XOR.
To prove this, we can check the truth table for both <code class="language-plaintext highlighter-rouge">x ^ y</code> and <code class="language-plaintext highlighter-rouge">y ^ x</code>:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">x</code></th>
      <th><code class="language-plaintext highlighter-rouge">y</code></th>
      <th><code class="language-plaintext highlighter-rouge">x ^ y</code></th>
      <th><code class="language-plaintext highlighter-rouge">y ^ x</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>As we can see, <code class="language-plaintext highlighter-rouge">x ^ y</code> and <code class="language-plaintext highlighter-rouge">y ^ x</code> always end up with the same value.</p>

<h4 id="sequences-of-xor-operations">Sequences of XOR operations</h4>

<p>By combining all of this, we can deduce the central insight behind everything that is about to follow:</p>

<blockquote>
  <p><strong>The XOR trick</strong>: If we have a sequence of XOR operations <code class="language-plaintext highlighter-rouge">a ^ b ^ c ^ ...</code>, then we can remove all pairs of duplicated values without affecting the result.</p>
</blockquote>

<p>Commutativity allows us to re-order the applications of XOR so that the duplicated elements are next to each other.
Since <code class="language-plaintext highlighter-rouge">x ^ x = 0</code> and <code class="language-plaintext highlighter-rouge">a ^ 0 = a</code>, each pair of duplicated values has no effect on the outcome.</p>

<p>Let’s go through an example of this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  a ^ b ^ c ^ a ^ b     # Commutativity
= a ^ a ^ b ^ b ^ c     # Using x ^ x = 0
= 0 ^ 0 ^ c             # Using x ^ 0 = x (and commutativity)
= c
</code></pre></div></div>

<p>Because <code class="language-plaintext highlighter-rouge">^</code> is a bitwise operator, this will work regardless of what kind of values <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">c</code> are.
This idea is really at the heart of how XOR can be used seemingly magically in many situations.</p>

<h3 id="application-1-in-place-swapping">Application 1: In-Place Swapping</h3>

<p>Before we solve the problem of finding the missing number, let’s start with this simpler <a href="https://www.geeksforgeeks.org/swap-two-numbers-without-using-temporary-variable/">problem</a>:</p>

<blockquote>
  <p>Swap two values x and y in-place, i.e. without using any helper variables.</p>
</blockquote>

<p>It turns out that one can easily solve this problem using the following three XOR instructions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x ^= y
y ^= x
x ^= y
</code></pre></div></div>

<p>That seems a bit mysterious.
Why do we end up swapping <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> if we do this?</p>

<p>To see how it works, let’s go through this step by step.
The comment after each instruction shows the current values of <code class="language-plaintext highlighter-rouge">(x, y)</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x ^= y # =&gt;                      (x ^ y, y)
y ^= x # =&gt; (x ^ y, y ^ x ^ y) = (x ^ y, x)
x ^= y # =&gt; (x ^ y ^ x, x)     = (y, x)
</code></pre></div></div>

<p>We can see that this is really just using the properties derived earlier.</p>

<p>The fundamental insight here is that having <code class="language-plaintext highlighter-rouge">x ^ y</code> in one register and <code class="language-plaintext highlighter-rouge">x</code> in the other, allows us to perfectly reconstruct <code class="language-plaintext highlighter-rouge">y</code>.
Once <code class="language-plaintext highlighter-rouge">x ^ y</code> is stored (instruction 1), we can just put <code class="language-plaintext highlighter-rouge">x</code> into the other register (instruction 2), and then use it to change <code class="language-plaintext highlighter-rouge">x ^ y</code> to just <code class="language-plaintext highlighter-rouge">y</code> (instruction 3).</p>

<h3 id="application-2-finding-the-missing-number">Application 2: Finding the Missing Number</h3>

<p>Let’s finally solve the problem posed in the beginning of this post:</p>

<blockquote>
  <p>You are given an array <code class="language-plaintext highlighter-rouge">A</code> of n - 1 integers which are in the range between 1 and n. All numbers appear exactly once, except one number, which is missing. Find this missing number.</p>
</blockquote>

<p>Of course, there are many straightforward ways of solving this, but we did set out to do it using XOR.</p>

<p>From the XOR trick we know that having a sequence of XOR statements means we can remove all duplicated arguments.
If we just XOR all values in the given list, however, we cannot apply this trick because there are no duplicates:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A[0] ^ A[1] ^ ... ^ A[n - 2]
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">A[n - 2]</code> is the last index of a list of <code class="language-plaintext highlighter-rouge">n - 1</code> elements.</p>

<p>What we can do additionally is to also XOR all values between 1 and n:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 ^ 2 ^ ... ^ n ^ A[0] ^ A[1] ^ ... ^ A[n - 2]
</code></pre></div></div>

<p>This will give us a sequence of XOR statements where elements appear as follows:</p>
<ul>
  <li>All values in the given list now appear twice:
    <ul>
      <li>once from taking all the values between 1 and n</li>
      <li>once because they were in the original list</li>
    </ul>
  </li>
  <li>The missing value appears exactly once:
    <ul>
      <li>once from taking all the values between 1 and n</li>
    </ul>
  </li>
</ul>

<p>If we XOR all of this, we essentially remove all values that appear twice, thanks to the XOR trick.
This means that we are left with the missing value, which happens to be exactly what we were looking for in the first place.</p>

<p>Coded up, it looks something like this:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_missing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
  <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="c1"># XOR of all the values from 1 to n
</span>  <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">^=</span> <span class="n">value</span>

  <span class="c1"># XOR of all values in the given array
</span>  <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">^=</span> <span class="n">value</span>

  <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>Just looking at the code, this seems to be a difficult to understand algorithm.
When knowing how the XOR trick works, however, it becomes fairly trivial.
I think that also shows why it is unreasonable to expect this solution in an interview: It requires knowledge of a very specific trick but not much algorithmic thinking beyond that.</p>

<p>Before we move on to the next application, let me follow up with two remarks.</p>

<h4 id="generalizing-this-beyond-integers">Generalizing this beyond integers</h4>

<p>While we worked on integers from 1 to n so far, this is not required.
In fact, the previous algorithm works in any situation where there is (1) some set of potential elements and (2) a set of elements actually appearing.
The sets may only differ in the one missing element.
This worked out nicely for integers because the set of potential elements just corresponds to the elements from 1 to n.</p>

<p>One could imagine applications where the elements are not integers from 1 to n:</p>
<ul>
  <li>The set of potential elements are <code class="language-plaintext highlighter-rouge">Person</code> objects and we ought to find the <code class="language-plaintext highlighter-rouge">Person</code> missing from a list of values</li>
  <li>The set of potential elements are all nodes in a graph and we are looking for a missing node</li>
  <li>The set of potential elements are integers in general (not necessarily from 1 to n) and we want to find a missing integer</li>
</ul>

<h4 id="arithmetic-operators-instead-of-xor">Arithmetic operators instead of XOR</h4>

<p>If the algorithm still seems a bit magical – which I hope it does not – it might help to think about how one could achieve the same result using arithmetic operators.
This is actually fairly straightforward:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_missing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
  <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="c1"># Add all the values from 1 to n
</span>  <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">value</span>

  <span class="c1"># Subtract all values in the given array
</span>  <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">-=</span> <span class="n">value</span>

  <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>We add all potential integers and then subtract the ones actually appearing.
The solution is not as nice because one would need to handle overflows and because it requires the type of the elements to support <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code> with certain properties.
It, however, has the same logic of elements canceling each other out because they appear a certain number of times (once positive, once negative).</p>

<h3 id="application-3-finding-the-duplicate-number">Application 3: Finding the Duplicate Number</h3>

<p>Here’s where it gets fun: We can apply the <em>exact</em> same solution to a similar interview question:</p>

<blockquote>
  <p>You are given an array <code class="language-plaintext highlighter-rouge">A</code> of <strong>n + 1</strong> integers which are in the range between 1 and n. All numbers appear exactly once, except one number, which is <strong>duplicated</strong>. Find this duplicated number.</p>
</blockquote>

<p>Let’s think about what happens if we just apply the exact same algorithm as in the previous solution.
We would get a sequence of XOR statements where elements appear as follows:</p>
<ul>
  <li>The duplicated value appears three times:
    <ul>
      <li>once from taking all the values between 1 and n</li>
      <li>twice because it was duplicated in the original list</li>
    </ul>
  </li>
  <li>All other values in the given list appear twice:
    <ul>
      <li>once from taking all the values between 1 and n</li>
      <li>once because they were unique in the original list</li>
    </ul>
  </li>
</ul>

<p>As previously, all the duplicated elements cancel each other out.
This means we are left with exactly what we are looking for: the element that was duplicated in the original array.
This element appearing three times, combined with XOR, reduces to that very element:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  x ^ x ^ x
= x ^ 0
= x
</code></pre></div></div>

<p>All other elements cancel each other out because they appear exactly twice.</p>

<h3 id="application-4-finding-two-missingduplicate-numbers">Application 4: Finding Two Missing/Duplicate Numbers</h3>

<p>It turns out we can take this even further.
Consider the following, slightly more difficult, problem:</p>

<blockquote>
  <p>You are given an array <code class="language-plaintext highlighter-rouge">A</code> of <strong>n - 2</strong> integers which are in the range between 1 and n. All numbers appear exactly once, except <strong>two</strong> numbers, which are missing. Find these two missing numbers.</p>
</blockquote>

<p>As before, the problem is completely equivalent when looking for two <em>duplicated</em> numbers, instead of two <em>missing</em> numbers.</p>

<p>And I am sure you guessed it, but we will stick with what worked before and start exactly the same way:
Let’s consider what happens if we use the previous XOR algorithm.
If we do that, we again end up with a sequence of XOR statements where all elements cancel each other out, except the two we are looking for.</p>

<p>We will denote these elements by <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code>, mostly because we have not used those letters before.
After applying the previous algorithm, we are thus left with <code class="language-plaintext highlighter-rouge">u ^ v</code>.
What can we do with that? We somehow need to extract <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code> from this value, but it is not immediately clear to do that.</p>

<h4 id="partitioning-based-on-inspecting-u--v">Partitioning based on inspecting <code class="language-plaintext highlighter-rouge">u ^ v</code></h4>

<p>Luckily, we can figure out what to do by using what we already stated earlier.
Let’s think about this:</p>

<blockquote>
  <p>If the two bits XOR takes as input are the same, the result is <code class="language-plaintext highlighter-rouge">0</code>, otherwise it is <code class="language-plaintext highlighter-rouge">1</code>.</p>
</blockquote>

<p>If we analyze the individual bits in <code class="language-plaintext highlighter-rouge">u ^ v</code>, then every <code class="language-plaintext highlighter-rouge">0</code> means that the bit had the same value in both <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code>. Every <code class="language-plaintext highlighter-rouge">1</code> means that the bits differed.</p>

<p>Using this, we find the first <code class="language-plaintext highlighter-rouge">1</code> in <code class="language-plaintext highlighter-rouge">u ^ v</code>, i.e. the first position <code class="language-plaintext highlighter-rouge">i</code> where <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code> have to differ.
Then we partition <code class="language-plaintext highlighter-rouge">A</code> as well as the numbers from 1 to n according to that bit. We end up with two partitions, each of which contains two sets:</p>
<ol>
  <li>Partition <code class="language-plaintext highlighter-rouge">0</code>
    <ol>
      <li>The set of all values from 1 to n where the <code class="language-plaintext highlighter-rouge">i</code>-th bit is <code class="language-plaintext highlighter-rouge">0</code></li>
      <li>The set of all values from A where the <code class="language-plaintext highlighter-rouge">i</code>-th bit is <code class="language-plaintext highlighter-rouge">0</code></li>
    </ol>
  </li>
  <li>Partition <code class="language-plaintext highlighter-rouge">1</code>
    <ol>
      <li>The set of all values from 1 to n where the <code class="language-plaintext highlighter-rouge">i</code>-th bit is <code class="language-plaintext highlighter-rouge">1</code></li>
      <li>The set of all values from A where the <code class="language-plaintext highlighter-rouge">i</code>-th bit is <code class="language-plaintext highlighter-rouge">1</code></li>
    </ol>
  </li>
</ol>

<p>Since <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code> differ in position <code class="language-plaintext highlighter-rouge">i</code>, we know that they have to be in different partitions.</p>

<h4 id="reducing-the-problem">Reducing the problem</h4>

<p>Next, we can use another insight described earlier:</p>
<blockquote>
  <p>While we worked on integers from 1 to n so far, this is not required.
In fact, the previous algorithm works in any situation where there is (1) some set of potential elements and (2) a set of elements actually appearing.
The sets may only differ in the one missing (or duplicated) element.</p>
</blockquote>

<p>These two sets correspond exactly to the sets we have in each partition.
We can thus search for <code class="language-plaintext highlighter-rouge">u</code> by applying this idea to one of the partitions and finding the missing element, and then find <code class="language-plaintext highlighter-rouge">v</code> by applying it to the other partition.</p>

<p>This is actually a pretty nice way of solving it: We effectively reduce this new problem to the more general version of the problem we solved earlier.</p>

<h3 id="reaching-the-limit">Reaching the Limit</h3>

<p>One might try to take this further and aim to solve the problem for more than two missing values.
I did not give this an abundance of thought, but I think this is where we stop succeeding with XOR.
If more than two elements are missing (or duplicated), then analyzing the individual bits fails because there are several combinations possible for both <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">1</code> as results.</p>

<p>The problem then seems to require <a href="https://www.youtube.com/watch?v=pKO9UjSeLew">more complex</a> solutions, which are not based on XOR anymore.</p>

<h3 id="final-thoughts">Final Thoughts</h3>

<p>As mentioned before, interview questions based on this trick do not seem like a great idea.
They require knowing a slightly obscure trick, but once that trick is known, there is not much left to solve (except maybe for application 4).
There is also barely a way to show algorithmic thinking (other than reduction) and no good way to make use of data structures.</p>

<p>However, I found it pretty cool to find out how this trick actually work.
XOR seems to have just the right properties for all of this to work out.
It is also kind of beautiful that something as fundamental as XOR can be used to build up all the things described here.</p>

<hr />

<p>Thanks to Eugen for the discussions that lead to this post.
It was fun to figure out together how all of this works.</p>

  </article>

  
  <div class="comments">
    <div id="disqus_thread"></div>
<script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://jihoon222.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  </div>
</div>

<script>
var anchorForId = function (id) {
  var anchor = document.createElement("a");
  anchor.className = "header-link";
  anchor.href      = "#" + id;
  anchor.innerHTML = "<i class=\"fas fa-link\"></i>";
  return anchor;
};

var linkifyAnchors = function (level, containingElement) {
  var headers = containingElement.getElementsByTagName("h" + level);
  for (var h = 0; h < headers.length; h++) {
    var header = headers[h];

    if (typeof header.id !== "undefined" && header.id !== "") {
      header.appendChild(anchorForId(header.id));
    }
  }
};

document.onreadystatechange = function () {
  if (this.readyState === "complete") {
    linkifyAnchors(3, document.body);
    linkifyAnchors(4, document.body);
    linkifyAnchors(5, document.body);
    linkifyAnchors(6, document.body);
  }
};
</script>

      </div>
    </div>
  </body>
</html>
